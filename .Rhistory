#subC <-  get_lpmf(yvec[c(1,3)], lengths[c(1,3)]) # for cluster {1,3}
#subD <-  get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {1,4}
#subE <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,3}
#subF <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,4}
all <- get_lpmf( yvec, lengths ) #log-like for collection {{1,2,3,4}}
#is guide tree binary
distFn <- function(x1, x2 ){
c1 <- x1[1]/x1[2]
c2 <- x2[1]/x2[2]
abs( c1-c2 )/max( c1, c2 )
}
dmat <- matrix(0, 4,4)
for( i in seq(1,4) ){
for(j in seq(1,4)){
if(i > j){
dmat[i,j] <- dmat[j,i]
} else {
xxi <- c(yvec[i], lengths[i])
xxj <- c(yvec[j], lengths[j])
dmat[i,j] <- distFn( xxi, xxj )
}
}
}
gt <- as.dist( dmat )
res <- list()
res$stats <- c("all"=all, "subA"=subA, "subB"=subB,
"subA3.4"=subA3.4, "subA4.3"=subA4.3,
"subB1.2"=subB1.2, "subB2.1"=subB2.1,
"indiv1"=indiv1, "indiv2"=indiv2, "indiv3"=indiv3, "indiv4"=indiv4
)
res$data <- list( "yvec"=yvec, "lengths"=lengths, "rates"=poiss_rates)
res$gt <- gt
res
}
k1 <- lapply( seq(1,50000), function(x){ sim() })
k  <- sapply( k1, function(x) x$stats )
M1 <- k["indiv1",]+k["indiv2",]+k["indiv3",]+k["indiv4",]-(4/2)*log(4) # { {1}, {2}, {3}, {4}  }
M2 <- k["subA",] + k["subB",] - (2/2)*log(4)  # { {1,2}, {3,4} }
M3 <- k["all",] - (1/2)*log(4)  # {  {1,2,3,4}  }
M5 <- k["subA", ] + k["indiv3",] + k["indiv4",] - (3/2)*log(4)
M6 <- k["subB", ] + k["indiv1",] + k["indiv2",] - (3/2)*log(4)
op <- par(mfrow=c(1,2), pty='s', mar=c(4,4,2,1))
smoothScatter( M1, M2-M1,
xlab = "M1 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M2 - M1, where M2 is the BIC for { {1,2}, {3,4} }"
); abline(h=0, lty=2)
# -- the pink points are those where the all-merge-type cluster {{1,2,3,4}} have higher BICs than { {1,2}, {3,4} }. For these pink points, our DP will choose the  all-merge-type cluster and consider it to have the maximum BIC for that part of the subtree.
indx <- which(M3>M2)
points( M1[indx], M2[indx]-M1[indx], col = 'pink', pch=19 ); abline(h=0, lty=2)
# -- the black circles encircle those pink points where { {1,2},{3}, {4} } have higher BICs than { {1,2,3,4} }
blackIndx <- indx[ which( M5[indx] > M3[indx] ) ]
points( M1[blackIndx], M2[blackIndx]-M1[blackIndx], col = 'black', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the green circles encircle those pink points where {{1},{2},{3,4}} have higher BICs than { {1,2,3,4} }
greenIndx <- indx[ which( M6[indx] > M3[indx] ) ]
points( M1[greenIndx], M2[greenIndx]-M1[greenIndx], col = 'green', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the red circles encircle those pink points where {{1},{2},{3},{4} } have higher BICs than { {1,2,3,4} }
redIndx <- indx[ which( M1[indx] > M3[indx] ) ]
points( M1[redIndx], M2[redIndx]-M1[redIndx], col = 'red', pch=1, cex=2 ); abline(h=0, lty=2)
### -- GUIDE TREES ---
# Draw the guide trees for those black circled points, that fall above the dashed lines
for(i in blackIndx){
plot( hclust( k1[[i]]$gt ), xlab = "Black circled point" )
}
blackIndx
i <- 1
plot( hclust( k1[[i]]$gt ), xlab = "Black circled point" )
sim <- function(){
#Step 1: Sample ONE cluster's poisson parameters, and assign the first parameter for first two nodes, and the second for second two nodes pushed over with higher rates
lam_sample <- rgamma(n=1, shape=5)
poiss_rates <- c( rep( lam_sample[1],2), rep( lam_sample[1]+2,2) )
#Step 2: assign random lengths and counts for the four contigs
lengths <- round( runif( 500, 200000, n=4 ) )
yvec <- sapply(poiss_rates*lengths, function(x) rpois( n=1, lambda=x ) )
#Step 3: Compute log likelihood with a Poisson, with rate paramters the MLEs
get_lpmf <- function(zvec, lengths){
rate <- sum(zvec)/sum(lengths)
sum( dpois( zvec, lambda = rate*lengths, log = T ) )
}
#Step 4: Log-likelihood computations for each individual contig
indiv1 <- get_lpmf(yvec[1], lengths[1])
indiv2 <- get_lpmf(yvec[2], lengths[2])
indiv3 <- get_lpmf(yvec[3], lengths[3])
indiv4 <- get_lpmf(yvec[4], lengths[4])
#Log-likelihood for some of the possible collection of clusters
subA <- get_lpmf(yvec[1:2], lengths[1:2])  #log-like for cluster {1,2},
subB <- get_lpmf(yvec[3:4], lengths[3:4])  #log-like for cluster {3,4}
subA3.4 <- get_lpmf(yvec[-4], lengths[-4]) + indiv4  #log-like for collection{ {1,2,3}, {4} },
subA4.3 <- get_lpmf(yvec[-3], lengths[-3]) + indiv3  # for collection {  {1,2,4}, {3} }
subB1.2 <-  get_lpmf(yvec[-2], lengths[-2]) + indiv2  # for collection {  {1,3,4}, {2} }
subB2.1 <-  get_lpmf(yvec[-1], lengths[-1]) + indiv1  # for collection {  {2,3,4}, {1} }
#subC <-  get_lpmf(yvec[c(1,3)], lengths[c(1,3)]) # for cluster {1,3}
#subD <-  get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {1,4}
#subE <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,3}
#subF <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,4}
all <- get_lpmf( yvec, lengths ) #log-like for collection {{1,2,3,4}}
#is guide tree binary
distFn <- function(x1, x2 ){
c1 <- x1[1]/x1[2]
c2 <- x2[1]/x2[2]
abs( c1-c2 )/max( c1, c2 )
}
dmat <- matrix(0, 4,4)
for( i in seq(1,4) ){
for(j in seq(1,4)){
if(i > j){
dmat[i,j] <- dmat[j,i]
} else {
xxi <- c(yvec[i], lengths[i])
xxj <- c(yvec[j], lengths[j])
dmat[i,j] <- distFn( xxi, xxj )
}
}
}
gt <- as.dist( dmat )
res <- list()
res$stats <- c("all"=all, "subA"=subA, "subB"=subB,
"subA3.4"=subA3.4, "subA4.3"=subA4.3,
"subB1.2"=subB1.2, "subB2.1"=subB2.1,
"indiv1"=indiv1, "indiv2"=indiv2, "indiv3"=indiv3, "indiv4"=indiv4
)
res$data <- list( "yvec"=yvec, "lengths"=lengths, "rates"=poiss_rates)
res$gt <- gt
res
}
k1 <- lapply( seq(1,50000), function(x){ sim() })
k  <- sapply( k1, function(x) x$stats )
M1 <- k["indiv1",]+k["indiv2",]+k["indiv3",]+k["indiv4",]-(4/2)*log(4) # { {1}, {2}, {3}, {4}  }
M2 <- k["subA",] + k["subB",] - (2/2)*log(4)  # { {1,2}, {3,4} }
M3 <- k["all",] - (1/2)*log(4)  # {  {1,2,3,4}  }
M5 <- k["subA", ] + k["indiv3",] + k["indiv4",] - (3/2)*log(4)
M6 <- k["subB", ] + k["indiv1",] + k["indiv2",] - (3/2)*log(4)
op <- par(mfrow=c(1,2), pty='s', mar=c(4,4,2,1))
smoothScatter( M1, M2-M1,
xlab = "M1 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M2 - M1, where M2 is the BIC for { {1,2}, {3,4} }"
); abline(h=0, lty=2)
# -- the pink points are those where the all-merge-type cluster {{1,2,3,4}} have higher BICs than { {1,2}, {3,4} }. For these pink points, our DP will choose the  all-merge-type cluster and consider it to have the maximum BIC for that part of the subtree.
indx <- which(M3>M2)
points( M1[indx], M2[indx]-M1[indx], col = 'pink', pch=19 ); abline(h=0, lty=2)
# -- the black circles encircle those pink points where { {1,2},{3}, {4} } have higher BICs than { {1,2,3,4} }
blackIndx <- indx[ which( M5[indx] > M3[indx] ) ]
points( M1[blackIndx], M2[blackIndx]-M1[blackIndx], col = 'black', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the green circles encircle those pink points where {{1},{2},{3,4}} have higher BICs than { {1,2,3,4} }
greenIndx <- indx[ which( M6[indx] > M3[indx] ) ]
points( M1[greenIndx], M2[greenIndx]-M1[greenIndx], col = 'green', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the red circles encircle those pink points where {{1},{2},{3},{4} } have higher BICs than { {1,2,3,4} }
redIndx <- indx[ which( M1[indx] > M3[indx] ) ]
points( M1[redIndx], M2[redIndx]-M1[redIndx], col = 'red', pch=1, cex=2 ); abline(h=0, lty=2)
sim <- function(){
#Step 1: Sample ONE cluster's poisson parameters, and assign the first parameter for first two nodes, and the second for second two nodes pushed over with higher rates
lam_sample <- rgamma(n=1, shape=5)
poiss_rates <- c( rep( lam_sample[1],2), rep( lam_sample[1]*2,2) )
#Step 2: assign random lengths and counts for the four contigs
lengths <- round( runif( 500, 200000, n=4 ) )
yvec <- sapply(poiss_rates*lengths, function(x) rpois( n=1, lambda=x ) )
#Step 3: Compute log likelihood with a Poisson, with rate paramters the MLEs
get_lpmf <- function(zvec, lengths){
rate <- sum(zvec)/sum(lengths)
sum( dpois( zvec, lambda = rate*lengths, log = T ) )
}
#Step 4: Log-likelihood computations for each individual contig
indiv1 <- get_lpmf(yvec[1], lengths[1])
indiv2 <- get_lpmf(yvec[2], lengths[2])
indiv3 <- get_lpmf(yvec[3], lengths[3])
indiv4 <- get_lpmf(yvec[4], lengths[4])
#Log-likelihood for some of the possible collection of clusters
subA <- get_lpmf(yvec[1:2], lengths[1:2])  #log-like for cluster {1,2},
subB <- get_lpmf(yvec[3:4], lengths[3:4])  #log-like for cluster {3,4}
subA3.4 <- get_lpmf(yvec[-4], lengths[-4]) + indiv4  #log-like for collection{ {1,2,3}, {4} },
subA4.3 <- get_lpmf(yvec[-3], lengths[-3]) + indiv3  # for collection {  {1,2,4}, {3} }
subB1.2 <-  get_lpmf(yvec[-2], lengths[-2]) + indiv2  # for collection {  {1,3,4}, {2} }
subB2.1 <-  get_lpmf(yvec[-1], lengths[-1]) + indiv1  # for collection {  {2,3,4}, {1} }
#subC <-  get_lpmf(yvec[c(1,3)], lengths[c(1,3)]) # for cluster {1,3}
#subD <-  get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {1,4}
#subE <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,3}
#subF <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,4}
all <- get_lpmf( yvec, lengths ) #log-like for collection {{1,2,3,4}}
#is guide tree binary
distFn <- function(x1, x2 ){
c1 <- x1[1]/x1[2]
c2 <- x2[1]/x2[2]
abs( c1-c2 )/max( c1, c2 )
}
dmat <- matrix(0, 4,4)
for( i in seq(1,4) ){
for(j in seq(1,4)){
if(i > j){
dmat[i,j] <- dmat[j,i]
} else {
xxi <- c(yvec[i], lengths[i])
xxj <- c(yvec[j], lengths[j])
dmat[i,j] <- distFn( xxi, xxj )
}
}
}
gt <- as.dist( dmat )
res <- list()
res$stats <- c("all"=all, "subA"=subA, "subB"=subB,
"subA3.4"=subA3.4, "subA4.3"=subA4.3,
"subB1.2"=subB1.2, "subB2.1"=subB2.1,
"indiv1"=indiv1, "indiv2"=indiv2, "indiv3"=indiv3, "indiv4"=indiv4
)
res$data <- list( "yvec"=yvec, "lengths"=lengths, "rates"=poiss_rates)
res$gt <- gt
res
}
k1 <- lapply( seq(1,50000), function(x){ sim() })
k  <- sapply( k1, function(x) x$stats )
M1 <- k["indiv1",]+k["indiv2",]+k["indiv3",]+k["indiv4",]-(4/2)*log(4) # { {1}, {2}, {3}, {4}  }
M2 <- k["subA",] + k["subB",] - (2/2)*log(4)  # { {1,2}, {3,4} }
M3 <- k["all",] - (1/2)*log(4)  # {  {1,2,3,4}  }
M5 <- k["subA", ] + k["indiv3",] + k["indiv4",] - (3/2)*log(4)
M6 <- k["subB", ] + k["indiv1",] + k["indiv2",] - (3/2)*log(4)
op <- par(mfrow=c(1,2), pty='s', mar=c(4,4,2,1))
smoothScatter( M1, M2-M1,
xlab = "M1 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M2 - M1, where M2 is the BIC for { {1,2}, {3,4} }"
); abline(h=0, lty=2)
# -- the pink points are those where the all-merge-type cluster {{1,2,3,4}} have higher BICs than { {1,2}, {3,4} }. For these pink points, our DP will choose the  all-merge-type cluster and consider it to have the maximum BIC for that part of the subtree.
indx <- which(M3>M2)
points( M1[indx], M2[indx]-M1[indx], col = 'pink', pch=19 ); abline(h=0, lty=2)
# -- the black circles encircle those pink points where { {1,2},{3}, {4} } have higher BICs than { {1,2,3,4} }
blackIndx <- indx[ which( M5[indx] > M3[indx] ) ]
points( M1[blackIndx], M2[blackIndx]-M1[blackIndx], col = 'black', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the green circles encircle those pink points where {{1},{2},{3,4}} have higher BICs than { {1,2,3,4} }
greenIndx <- indx[ which( M6[indx] > M3[indx] ) ]
points( M1[greenIndx], M2[greenIndx]-M1[greenIndx], col = 'green', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the red circles encircle those pink points where {{1},{2},{3},{4} } have higher BICs than { {1,2,3,4} }
redIndx <- indx[ which( M1[indx] > M3[indx] ) ]
points( M1[redIndx], M2[redIndx]-M1[redIndx], col = 'red', pch=1, cex=2 ); abline(h=0, lty=2)
sim <- function(){
#Step 1: Sample ONE cluster's poisson parameters, and assign the first parameter for first two nodes, and the second for second two nodes pushed over with higher rates
lam_sample <- rgamma(n=1, shape=5)
poiss_rates <- c( rep( lam_sample[1],2), rep( lam_sample[1]*2,2) )
#Step 2: assign random lengths and counts for the four contigs
lengths <- round( runif( 500, 200000, n=4 ) )
yvec <- sapply(poiss_rates*lengths, function(x) rpois( n=1, lambda=x ) )
#Step 3: Compute log likelihood with a Poisson, with rate paramters the MLEs
get_lpmf <- function(zvec, lengths){
rate <- sum(zvec)/sum(lengths)
sum( dpois( zvec, lambda = rate*lengths, log = T ) )
}
#Step 4: Log-likelihood computations for each individual contig
indiv1 <- get_lpmf(yvec[1], lengths[1])
indiv2 <- get_lpmf(yvec[2], lengths[2])
indiv3 <- get_lpmf(yvec[3], lengths[3])
indiv4 <- get_lpmf(yvec[4], lengths[4])
#Log-likelihood for some of the possible collection of clusters
subA <- get_lpmf(yvec[1:2], lengths[1:2])  #log-like for cluster {1,2},
subB <- get_lpmf(yvec[3:4], lengths[3:4])  #log-like for cluster {3,4}
subA3.4 <- get_lpmf(yvec[-4], lengths[-4]) + indiv4  #log-like for collection{ {1,2,3}, {4} },
subA4.3 <- get_lpmf(yvec[-3], lengths[-3]) + indiv3  # for collection {  {1,2,4}, {3} }
subB1.2 <-  get_lpmf(yvec[-2], lengths[-2]) + indiv2  # for collection {  {1,3,4}, {2} }
subB2.1 <-  get_lpmf(yvec[-1], lengths[-1]) + indiv1  # for collection {  {2,3,4}, {1} }
#subC <-  get_lpmf(yvec[c(1,3)], lengths[c(1,3)]) # for cluster {1,3}
#subD <-  get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {1,4}
#subE <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,3}
#subF <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,4}
all <- get_lpmf( yvec, lengths ) #log-like for collection {{1,2,3,4}}
#is guide tree binary
distFn <- function(x1, x2 ){
c1 <- x1[1]/x1[2]
c2 <- x2[1]/x2[2]
abs( c1-c2 )/max( c1, c2 )
}
dmat <- matrix(0, 4,4)
for( i in seq(1,4) ){
for(j in seq(1,4)){
if(i > j){
dmat[i,j] <- dmat[j,i]
} else {
xxi <- c(yvec[i], lengths[i])
xxj <- c(yvec[j], lengths[j])
dmat[i,j] <- distFn( xxi, xxj )
}
}
}
gt <- as.dist( dmat )
res <- list()
res$stats <- c("all"=all, "subA"=subA, "subB"=subB,
"subA3.4"=subA3.4, "subA4.3"=subA4.3,
"subB1.2"=subB1.2, "subB2.1"=subB2.1,
"indiv1"=indiv1, "indiv2"=indiv2, "indiv3"=indiv3, "indiv4"=indiv4
)
res$data <- list( "yvec"=yvec, "lengths"=lengths, "rates"=poiss_rates)
res$gt <- gt
res
}
k1 <- lapply( seq(1,50000), function(x){ sim() })
k  <- sapply( k1, function(x) x$stats )
M1 <- k["indiv1",]+k["indiv2",]+k["indiv3",]+k["indiv4",]-(4/2)*log(4) # { {1}, {2}, {3}, {4}  }
M2 <- k["subA",] + k["subB",] - (2/2)*log(4)  # { {1,2}, {3,4} }
M3 <- k["all",] - (1/2)*log(4)  # {  {1,2,3,4}  }
M5 <- k["subA", ] + k["indiv3",] + k["indiv4",] - (3/2)*log(4)
M6 <- k["subB", ] + k["indiv1",] + k["indiv2",] - (3/2)*log(4)
op <- par(mfrow=c(1,2), pty='s', mar=c(4,4,2,1))
smoothScatter( M1, M2-M1,
xlab = "M1 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M2 - M1, where M2 is the BIC for { {1,2}, {3,4} }"
); abline(h=0, lty=2)
# -- the pink points are those where the all-merge-type cluster {{1,2,3,4}} have higher BICs than { {1,2}, {3,4} }. For these pink points, our DP will choose the  all-merge-type cluster and consider it to have the maximum BIC for that part of the subtree.
indx <- which(M3>M2)
points( M1[indx], M2[indx]-M1[indx], col = 'pink', pch=19 ); abline(h=0, lty=2)
# -- the black circles encircle those pink points where { {1,2},{3}, {4} } have higher BICs than { {1,2,3,4} }
blackIndx <- indx[ which( M5[indx] > M3[indx] ) ]
points( M1[blackIndx], M2[blackIndx]-M1[blackIndx], col = 'black', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the green circles encircle those pink points where {{1},{2},{3,4}} have higher BICs than { {1,2,3,4} }
greenIndx <- indx[ which( M6[indx] > M3[indx] ) ]
points( M1[greenIndx], M2[greenIndx]-M1[greenIndx], col = 'green', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the red circles encircle those pink points where {{1},{2},{3},{4} } have higher BICs than { {1,2,3,4} }
redIndx <- indx[ which( M1[indx] > M3[indx] ) ]
points( M1[redIndx], M2[redIndx]-M1[redIndx], col = 'red', pch=1, cex=2 ); abline(h=0, lty=2)
cyanIndx <- indx[ which( M1[indx] > M2[indx] ) ]
points( M1[cyanIndx], M2[cyanIndx]-M1[cyanIndx], col = 'red', pch=1, cex=2 ); abline(h=0, lty=2)
cyanIndx
M1
M2
sim <- function(){
#Step 1: Sample ONE cluster's poisson parameters, and assign the first parameter for first two nodes, and the second for second two nodes pushed over with higher rates
lam_sample <- rgamma(n=2, shape=5)
poiss_rates <- c( rep( lam_sample[1],2), rep( lam_sample[2],2) )
#Step 2: assign random lengths and counts for the four contigs
lengths <- round( runif( 500, 200000, n=4 ) )
yvec <- sapply(poiss_rates*lengths, function(x) rpois( n=1, lambda=x ) )
#Step 3: Compute log likelihood with a Poisson, with rate paramters the MLEs
get_lpmf <- function(zvec, lengths){
rate <- sum(zvec)/sum(lengths)
sum( dpois( zvec, lambda = rate*lengths, log = T ) )
}
#Step 4: Log-likelihood computations for each individual contig
indiv1 <- get_lpmf(yvec[1], lengths[1])
indiv2 <- get_lpmf(yvec[2], lengths[2])
indiv3 <- get_lpmf(yvec[3], lengths[3])
indiv4 <- get_lpmf(yvec[4], lengths[4])
#Log-likelihood for some of the possible collection of clusters
subA <- get_lpmf(yvec[1:2], lengths[1:2])  #log-like for cluster {1,2},
subB <- get_lpmf(yvec[3:4], lengths[3:4])  #log-like for cluster {3,4}
subA3.4 <- get_lpmf(yvec[-4], lengths[-4]) + indiv4  #log-like for collection{ {1,2,3}, {4} },
subA4.3 <- get_lpmf(yvec[-3], lengths[-3]) + indiv3  # for collection {  {1,2,4}, {3} }
subB1.2 <-  get_lpmf(yvec[-2], lengths[-2]) + indiv2  # for collection {  {1,3,4}, {2} }
subB2.1 <-  get_lpmf(yvec[-1], lengths[-1]) + indiv1  # for collection {  {2,3,4}, {1} }
#subC <-  get_lpmf(yvec[c(1,3)], lengths[c(1,3)]) # for cluster {1,3}
#subD <-  get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {1,4}
#subE <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,3}
#subF <- get_lpmf(yvec[c(1,4)], lengths[c(1,4)])  # for collection {2,4}
all <- get_lpmf( yvec, lengths ) #log-like for collection {{1,2,3,4}}
#is guide tree binary
distFn <- function(x1, x2 ){
c1 <- x1[1]/x1[2]
c2 <- x2[1]/x2[2]
abs( c1-c2 )/max( c1, c2 )
}
dmat <- matrix(0, 4,4)
for( i in seq(1,4) ){
for(j in seq(1,4)){
if(i > j){
dmat[i,j] <- dmat[j,i]
} else {
xxi <- c(yvec[i], lengths[i])
xxj <- c(yvec[j], lengths[j])
dmat[i,j] <- distFn( xxi, xxj )
}
}
}
gt <- as.dist( dmat )
res <- list()
res$stats <- c("all"=all, "subA"=subA, "subB"=subB,
"subA3.4"=subA3.4, "subA4.3"=subA4.3,
"subB1.2"=subB1.2, "subB2.1"=subB2.1,
"indiv1"=indiv1, "indiv2"=indiv2, "indiv3"=indiv3, "indiv4"=indiv4
)
res$data <- list( "yvec"=yvec, "lengths"=lengths, "rates"=poiss_rates)
res$gt <- gt
res
}
k1 <- lapply( seq(1,50000), function(x){ sim() })
k  <- sapply( k1, function(x) x$stats )
M1 <- k["indiv1",]+k["indiv2",]+k["indiv3",]+k["indiv4",]-(4/2)*log(4) # { {1}, {2}, {3}, {4}  }
M2 <- k["subA",] + k["subB",] - (2/2)*log(4)  # { {1,2}, {3,4} }
M3 <- k["all",] - (1/2)*log(4)  # {  {1,2,3,4}  }
M5 <- k["subA", ] + k["indiv3",] + k["indiv4",] - (3/2)*log(4)
M6 <- k["subB", ] + k["indiv1",] + k["indiv2",] - (3/2)*log(4)
op <- par(mfrow=c(1,2), pty='s', mar=c(4,4,2,1))
smoothScatter( M1, M2-M1,
xlab = "M1 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M2 - M1, where M2 is the BIC for { {1,2}, {3,4} }"
); abline(h=0, lty=2)
# -- the pink points are those where the all-merge-type cluster {{1,2,3,4}} have higher BICs than { {1,2}, {3,4} }. For these pink points, our DP will choose the  all-merge-type cluster and consider it to have the maximum BIC for that part of the subtree.
indx <- which(M3>M2)
points( M1[indx], M2[indx]-M1[indx], col = 'pink', pch=19 ); abline(h=0, lty=2)
# -- the black circles encircle those pink points where { {1,2},{3}, {4} } have higher BICs than { {1,2,3,4} }
blackIndx <- indx[ which( M5[indx] > M3[indx] ) ]
points( M1[blackIndx], M2[blackIndx]-M1[blackIndx], col = 'black', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the green circles encircle those pink points where {{1},{2},{3,4}} have higher BICs than { {1,2,3,4} }
greenIndx <- indx[ which( M6[indx] > M3[indx] ) ]
points( M1[greenIndx], M2[greenIndx]-M1[greenIndx], col = 'green', pch=1, cex=2 ); abline(h=0, lty=2)
# -- the red circles encircle those pink points where {{1},{2},{3},{4} } have higher BICs than { {1,2,3,4} }
redIndx <- indx[ which( M1[indx] > M3[indx] ) ]
points( M1[redIndx], M2[redIndx]-M1[redIndx], col = 'red', pch=1, cex=2 ); abline(h=0, lty=2)
cyanIndx <- indx[ which( M1[indx] > M2[indx] ) ]
points( M1[cyanIndx], M2[cyanIndx]-M1[cyanIndx], col = 'red', pch=1, cex=2 ); abline(h=0, lty=2)
### -- GUIDE TREES ---
# Draw the guide trees for those black circled points, that fall above the dashed lines
for(i in blackIndx){
plot( hclust( k1[[i]]$gt ), xlab = "Black circled point" )
}
# Draw the guide trees for a few greenIndx
for(i in greenIndx){
plot( hclust( k1[[i]]$gt ), xlab = "Green circled point" )
}
# Draw the guide trees for a few greenIndx
for(i in redIndx){
plot( hclust( k1[[i]]$gt ), xlab = "Green circled point" )
}
par(op)
smoothScatter( M1, M3-M1,
xlab = "M1 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M3 - M1, where M# is the BIC for { {1,2, 3,4} }"
); abline(h=0, lty=2)
smoothScatter( M1, M3-M1,
xlab = "M3 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M3 - M1, where M# is the BIC for { {1,2, 3,4} }"
); abline(h=0, lty=2)
smoothScatter( M3, M3-M1,
xlab = "M3 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M3 - M1, where M# is the BIC for { {1,2, 3,4} }"
); abline(h=0, lty=2)
op <- par(mfrow=c(1,2), pty='s', mar=c(4,4,2,1))
smoothScatter( M1, M2-M1,
xlab = "M1 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M2 - M1, where M2 is the BIC for { {1,2}, {3,4} }"
); abline(h=0, lty=2)
op <- par(mfrow=c(1,2), pty='s', mar=c(4,4,2,1))
smoothScatter( M1, M2-M1,
xlab = "M1 : BIC for {{1}, {2}, {3}, {4}}",
ylab = "M2 - M1, where M2 is the BIC for { {1,2}, {3,4} }"
); abline(h=0, lty=2)
# -- the pink points are those where the all-merge-type cluster {{1,2,3,4}} have higher BICs than { {1,2}, {3,4} }. For these pink points, our DP will choose the  all-merge-type cluster and consider it to have the maximum BIC for that part of the subtree.
indx <- which(M3>M2)
points( M1[indx], M2[indx]-M1[indx], col = 'pink', pch=19 ); abline(h=0, lty=2)
# -- the black circles encircle those pink points where { {1,2},{3}, {4} } have higher BICs than { {1,2,3,4} }
blackIndx <- indx[ which( M5[indx] > M3[indx] ) ]
points( M1[blackIndx], M2[blackIndx]-M1[blackIndx], col = 'black', pch=1, cex=2 ); abline(h=0, lty=2)
k1[[1]]
k1[[1]]$gt
k1[[indx[1]]]$gt
rpois( n=2, lambda = 1e3)
f <- rpois( n=2, lambda = 1e5)
f <- rpois( n=2, lambda = 1*l)
l <- 1e5;
f <- rpois( n=2, lambda = 1*l)
f <- rpois( n=2, lambda = 1*l)
l <- c(1e3, 1e5);
f <- rpois( n=2, lambda = 1*l)
f
y <- rpois( n=2, lambda = 1*l)
node_lev <- y/l
node_cov <- y/l
overall_cov <- sum(y)/sum(l)
node_cov <- y/l
node_cov <- y/l ; bic1 <- sum( dpois( y, lambda = node_cov*l , log=T )   ) - (2/2)*log(2)
node_cov <- y/l ; two_bics_1 <- dpois( y, lambda = node_cov*l , log=T )   - (1/2)*log(2)
overall_cov <- sum(y)/sum(l); bic2 <- dpois( y, lambda=overall_cov*l, log=T) - (1/2)*log(2)
bic2 > sum(two_bics_1)
overall_cov <- sum(y)/sum(l); bic2 <- sum( dpois( y, lambda=overall_cov*l, log=T)) - (1/2)*log(2)
bic2 > sum(two_bics_1)
bic2 == sum(two_bics_1)
l <- c(1e3, 1e5);
kk <- sapply(seq(1,1000), function(i){
y <- rpois( n=2, lambda = 1*l)
node_cov <- y/l ; two_bics_1 <- dpois( y, lambda = node_cov*l , log=T )   - (1/2)*log(2)
overall_cov <- sum(y)/sum(l); bic2 <- sum( dpois( y, lambda=overall_cov*l, log=T)) - (1/2)*log(2)
bic2 == sum(two_bics_1)
})
barplot( 1*bic2 )
hist( 1*bic2 )
kk <- sapply(seq(1,1000), function(i){
y <- rpois( n=2, lambda = 1*l)
node_cov <- y/l ; two_bics_1 <- dpois( y, lambda = node_cov*l , log=T )   - (1/2)*log(2)
overall_cov <- sum(y)/sum(l); bic2 <- sum( dpois( y, lambda=overall_cov*l, log=T)) - (1/2)*log(2)
bic2 > sum(two_bics_1)
})
hist( 1*bic2 )
two_bics_1
bic2
l <- c(1e3, 1e5);
y <- rpois( n=2, lambda = 1*l)
node_cov <- y/l ; two_bics_1 <- dpois( y, lambda = node_cov*l , log=T )   - (1/2)*log(2)
overall_cov <- sum(y)/sum(l); bic2 <- sum( dpois( y, lambda=overall_cov*l, log=T)) - (1/2)*log(2)
y <- rpois( n=2, lambda = 1*l)
node_cov <- y/l ; two_bics_1 <- dpois( y, lambda = node_cov*l , log=T )   - (1/2)*log(2)
overall_cov <- sum(y)/sum(l); bic2 <- sum( dpois( y, lambda=overall_cov*l, log=T)) - (1/2)*log(2)
bic2 == sum(two_bics_1)
bic2
sum(two_bics_1)
library(Wrench)
library(Wrench)
vignette(Wrench)
?vignette
vignette(Limma)
vignette("limma")
vignette("Wrench")
browseVignettes("Wrench")
browseVignettes("Wrench")
library(Wrench)
library(Wrench)
devtools::build_vignettes()
library(Wrench)
browseVignettes("Wrench")
devtools::build_vignettes()
library(Wrench)
browseVignettes("Wrench")
