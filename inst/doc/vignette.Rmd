---
title: "Wrench"
author: "M. Senthil Kumar, HÃ©ctor Corrada Bravo"
date: "9/18/2018"
output: html_document
vignette: >
  %\VignetteIndexEntry{Wrench}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

require(metagenomeSeq)
require(edgeR)
require(Wrench)
require(DESeq2)

```

\emph{Wrench} is a normalization technique for metagenomic count data. While principally developed for sparse 16S count data from metagenomic experiments, it can also be applied to normalizing count data from other sparse technologies like single cell RNAseq, functional microbiome etc.,. 

Given (a) count data organized as features (OTUs, genes etc.,) x samples, and (b) experimental group labels associated with samples, Wrench outputs a normalization factor for each sample. The data is normalized by dividing each sample's counts with its normalization factor. 

The manuscript can be accessed here: [REF]

## Quick short story/background
An unwanted side-effect of DNA sequencing is that the observed counts retain only relative expression/abundance information. Comparing such relative abundances between experimental conditions/groups (for e.g., with differential abundance analysis) can lead to incorrect inferences . Specifically, features that are truly not perturbed in their absolute abundances can be identified as being differentially abundant. Commonly used techniques like rarefaction/subsampling/dividing by the total count and other variants of these approaches, do not correct for this issue. Wrench was developed to address this problem of reconstructing absolute from relative abundances based on some commonly exploited assumptions in genomics. 

The manuscript presented here: goes into other details. Fig. 1 and table 1 presented in the manuscript provide some perspective on various commonly used normalization techniques from the above standpoint, and we recommend reading through them. 

## Running Wrench
We pass count data, and group information and below, we present a quick tutorial. Details on any optional parameters are provided by typing "?wrench" in the R terminal window.

```{r, warning=FALSE}
#extract count and group information for from the mouse microbiome data in the metagenomeSeq package
data(mouseData)
counts <- MRcounts( mouseData, norm=F ) 
group <- pData(mouseData)$diet

#Running wrench with defaults
W <- wrench( counts, condition=group  )
compositionalFactors <- W$ccf
normalizationFactors <- W$nf

```

## For most commonly used differential abundance pipelines
```{r, warning=FALSE}
#Introducing the above normalization factors for the most
# commonly used tools is shown below.

# -- If using edgeR, we must pass in the compositional factors
edgerobj <- DGEList( counts=counts,
                     group = as.matrix(group),
                     norm.factors=compositionalFactors )

# -- If using DESeq/DESeq2
deseq.obj <- DESeqDataSetFromMatrix(countData = counts,
                                   DataFrame(group),
                                   ~ group )
DESeq2::sizeFactors(deseq.obj) <- normalizationFactors

# -- If using metagenomeSeq
normalizedObject <- mouseData
pData(normalizedObject@expSummary$expSummary)$normFactors <- normalizationFactors
```

## Some caveats / work in development
Wrench currently implements strategies for categorical group labels only. While extension to continuous covariates is still in development, you can create factors/levels out of your continuous covariates (however you think is reasonable) by discretizing/cutting them in pieces. 
```{r, warning=FALSE}
time <- as.numeric(as.character(pData(mouseData)$relativeTime))
time.levs <- cut( time, breaks = c(0, 6, 28, 42, 56, 70) )
overall_group <- paste( group, time.levs ) #merge the time information and the group information together
W <- wrench( counts, condition = overall_group )
```


